/*
** EPITECH PROJECT, 2023
** B-CPE-200-RUN-2-1-corewar-pierre-alexandre.grosset
** File description:
** corewar_programm_header
*/

////////////////////////////////////////////////////////////////////////////////
/// \file corewar_programm_header.h
/// \brief Contains all the includes and defines for the corewar program.
/// \authors PAGY0Z, Amdjadouxx, AxsOne, DarkCat974
/// \version 0.1
/// \date 2023-23-04
////////////////////////////////////////////////////////////////////////////////

#ifndef COREWAR_PROGRAMM_HEADER_H_
    #define COREWAR_PROGRAMM_HEADER_H_

    #include "include_header.h"

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR
    /// \brief All the DEFINES FUNCTIONS MACROS TYPEDEFS AND GLOBALS ARRAY
    /// from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWARMACROS_DEFINES
    /// \brief All the MACROS and DEFINES from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The extension of the asm files.
    /// \def EXT_ASM
    /// \note The extension is ".s".
    ////////////////////////////////////////////////////////////////////////////
    #define EXT_ASM ".s"

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The extension of the cor files.
    /// \def EXT_COR
    /// \note The extension is ".cor".
    ////////////////////////////////////////////////////////////////////////////
    #define EXT_COR ".cor"

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The arena size.
    /// \def MEM_SIZE
    /// \note The size is 6 * 1024.
    ////////////////////////////////////////////////////////////////////////////
    #define MEM_SIZE (6 * 1024)

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The number of registers.
    /// \def REG_NUMBER
    /// \note The number is 16.
    ////////////////////////////////////////////////////////////////////////////
    #define REG_NUMBER 16

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The number of live before checking how many are alive.
    /// \def NBR_LIVE
    /// \note The number is 40.
    ////////////////////////////////////////////////////////////////////////////
    #define NBR_LIVE 40

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The number of cycles before decreasing the cycle to die.
    /// \def CYCLE_TO_DIE
    /// \note The number is 1536.
    ////////////////////////////////////////////////////////////////////////////
    #define CYCLE_TO_DIE 1536

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The number of cycles decreasing the cycle to die.
    /// \def CYCLE_DELTA
    /// \note The number is 5.
    ////////////////////////////////////////////////////////////////////////////
    #define CYCLE_DELTA 5

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The magic number.
    /// \def MAGIC_NUMBER
    /// \note The number is 0xea83f3. Because why not ?
    ////////////////////////////////////////////////////////////////////////////
    #define MAGIC_NUMBER_VALUE 0xea83f3

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The reverse magic number.
    /// \def REV_MAGIC_NUMBER
    /// \note The number is 0xf383ae.
    ////////////////////////////////////////////////////////////////////////////
    #define REV_MAGIC_NUMBER 0xf383ea00

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The size of the magic number.
    /// \def MAGIC_NUMBER_SIZE
    /// \note The size is 4 bytes.
    ////////////////////////////////////////////////////////////////////////////
    #define MAGIC_NUMBER_SIZE 4

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The size of the name of the program.
    /// \def PROG_NAME_LENGTH
    /// \note The size is 128 bytes.
    ////////////////////////////////////////////////////////////////////////////
    #define PROG_NAME_LENGTH 128

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The size of the program.
    /// \def PROG_SIZE
    /// \note The size is 4 bytes.
    ////////////////////////////////////////////////////////////////////////////
    #define PROG_SIZE 4

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The size of the comment of the program.
    /// \def COMMENT_LENGTH
    /// \note The size is 2048 bytes.
    ////////////////////////////////////////////////////////////////////////////
    #define COMMENT_LENGTH 2048

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The MAGIC NUMBER + NAME
    /// \def LEN_MAGIC_NAME
    /// \note The size is 132 bytes.
    ////////////////////////////////////////////////////////////////////////////
    #define LEN_MAGIC_NAME (MAGIC_NUMBER_SIZE + PROG_NAME_LENGTH)

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The MAGIC NUMBER + NAME + PADDING
    /// \def LEN_MAGIC_NAME_PADDING
    /// \note The size is 136 bytes.
    ////////////////////////////////////////////////////////////////////////////
    #define LEN_MAGIC_NAME_PADDING (LEN_MAGIC_NAME + 4)

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The MAGIC NUMBER + NAME + PADDING + SIZE
    /// \def LEN_MAGIC_NAME_PADDING_SIZE
    /// \note The size is 140 bytes.
    ////////////////////////////////////////////////////////////////////////////
    #define LEN_MAGIC_NAME_PADDING_SIZE (LEN_MAGIC_NAME_PADDING + PROG_SIZE)

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The MAGIC NUMBER + NAME + PADDING + SIZE + COMMENT + PADDING
    /// \def FULL_HEADER_SIZE
    /// \note The size is 2192 bytes.
    ////////////////////////////////////////////////////////////////////////////
    #define FULL_HEADER_SIZE (LEN_MAGIC_NAME_PADDING_SIZE + COMMENT_LENGTH + 4)

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The value of OTHER.
    /// \def OTH
    /// \note The value is 0.
    ////////////////////////////////////////////////////////////////////////////
    #define OTH 0

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The value of REGISTER.
    /// \def REG
    /// \note The value is 1.
    ////////////////////////////////////////////////////////////////////////////
    #define REG 1

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The value of DIRECT.
    /// \def DIR
    /// \note The value is 2.
    ////////////////////////////////////////////////////////////////////////////
    #define DIR 2

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The value of INDIRECT.
    /// \def IND
    /// \note The value is 3.
    ////////////////////////////////////////////////////////////////////////////
    #define IND 3

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The value of a DIR with an index.
    /// \def DIR_IDX
    /// \note The value is 5.
    ////////////////////////////////////////////////////////////////////////////
    #define DIR_IDX 5

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The IDX_MOD.
    /// \def IDX_MOD
    /// \note The value is 512.
    ////////////////////////////////////////////////////////////////////////////
    #define IDX_MOD 512

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Check if the argument is OTHER.
    /// \def IS_OTH(x)
    /// \param x The argument to check.
    /// \return 1 if the argument is OTHER, 0 otherwise.
    ////////////////////////////////////////////////////////////////////////////
    #define IS_OTH(x) (x == OTH)

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Check if the argument is REGISTER.
    /// \def IS_REG(x)
    /// \param x The argument to check.
    /// \return 1 if the argument is REGISTER, 0 otherwise.
    ////////////////////////////////////////////////////////////////////////////
    #define IS_REG(x) (x == REG)

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Check if the argument is INDIRECT.
    /// \def IS_IND(x)
    /// \param x The argument to check.
    /// \return 1 if the argument is INDIRECT, 0 otherwise.
    ////////////////////////////////////////////////////////////////////////////
    #define IS_IND(x) (x == IND)

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Check if the argument is REGISTER or DIRECT.
    /// \def IS_REG_DIR(x)
    /// \param x The argument to check.
    /// \return 1 if the argument is REGISTER or DIRECT, 0 otherwise.
    ////////////////////////////////////////////////////////////////////////////
    #define IS_DIR(x) (x == DIR)

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Gets specific bits from a byte.
    /// \def GET_BITS(B, Sb, Nb)
    /// \param B The byte to get the bits from.
    /// \param Sb The starting bit.
    /// \param Nb The number of bits to get.
    /// \return The bits from the byte.
    ////////////////////////////////////////////////////////////////////////////
    #define GET_BITS(B, Sb, Nb) (((B) >> (Sb)) & ((1 << (Nb)) - 1))

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Gets the first parameter from an instruction.
    /// \def P1(byte)
    /// \param byte The instruction.
    /// \return The first parameter.
    ////////////////////////////////////////////////////////////////////////////
    #define P1(byte) GET_BITS(byte, 6, 2)

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Gets the second parameter from an instruction.
    /// \def P2(byte)
    /// \param byte The instruction.
    /// \return The second parameter.
    ////////////////////////////////////////////////////////////////////////////
    #define P2(byte) GET_BITS(byte, 4, 2)

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Gets the third parameter from an instruction.
    /// \def P3(byte)
    /// \param byte The instruction.
    /// \return The third parameter.
    ////////////////////////////////////////////////////////////////////////////
    #define P3(byte) GET_BITS(byte, 2, 2)

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Gets the fourth parameter from an instruction.
    /// \def P4(byte)
    /// \param byte The instruction.
    /// \return The fourth parameter.
    ////////////////////////////////////////////////////////////////////////////
    #define P4(byte) GET_BITS(byte, 0, 2)

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Check if the argument is REGISTER or DIRECT or INDIRECT.
    /// \def RDI(x)
    /// \param x The argument to check.
    /// \return 1 if the argument is REGISTER or DIRECT or INDIRECT, 0 otherwise
    ////////////////////////////////////////////////////////////////////////////
    #define RDI(x) (!(IS_REG(x)) && !(IS_DIR(x)) && !(IS_IND(x)))

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Converts 4 chars into an int.
    /// \def CTI(a, b, c, d)
    /// \param a The first char.
    /// \param b The second char.
    /// \param c The third char.
    /// \param d The fourth char.
    /// \return The int.
    ////////////////////////////////////////////////////////////////////////////
    #define CTI(a, b, c, d) (((a) << 24) | ((b) << 16) | ((c) << 8) | (d))

    ////////////////////////////////////////////////////////////////////////////
    /// @}
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_TYPEDEFS
    /// \brief All the TYPEDEFS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \typedef
    /// \brief The structure for the programs parameters of the corewar program.
    /// \struct params_progs_s
    ////////////////////////////////////////////////////////////////////////////
    typedef struct params_progs_s {
        ////////////////////////////////////////////////////////////////////////
        /// \brief The ID number of the program.
        ////////////////////////////////////////////////////////////////////////
        int prog_nbr;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The load adress of the program.
        ////////////////////////////////////////////////////////////////////////
        int load_address;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The path of the .cor program file.
        ////////////////////////////////////////////////////////////////////////
        char *prog_name;
    } params_progs_t;

    ////////////////////////////////////////////////////////////////////////////
    /// \typedef
    /// \brief The structure for the parameters of the corewar program.
    /// \struct params_progs_s
    ////////////////////////////////////////////////////////////////////////////
    typedef struct params_s {
        ////////////////////////////////////////////////////////////////////////
        /// \brief The number of cycles before the dump.
        ////////////////////////////////////////////////////////////////////////
        int dump_nbr_cycles;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The number of programs.
        ////////////////////////////////////////////////////////////////////////
        int prog_nbr;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The array of programs parameters.
        ////////////////////////////////////////////////////////////////////////
        params_progs_t **progs;
    } params_t;

    ////////////////////////////////////////////////////////////////////////////
    /// \typedef
    /// \brief
    /// \struct champ_s
    ////////////////////////////////////////////////////////////////////////////
    typedef struct champ_s {
        ////////////////////////////////////////////////////////////////////////
        /// \brief The comment of the champion.
        ////////////////////////////////////////////////////////////////////////
        char *comment;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The name of the champion.
        ////////////////////////////////////////////////////////////////////////
        char *name;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The registers of the champion.
        ////////////////////////////////////////////////////////////////////////
        int *regs;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The instructions params of the champion.
        ////////////////////////////////////////////////////////////////////////
        byte_t *params;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The ID number of the champion.
        ////////////////////////////////////////////////////////////////////////
        int prog_nbr;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The PC of the champion.
        ////////////////////////////////////////////////////////////////////////
        int pc;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The carry of the champion.
        ////////////////////////////////////////////////////////////////////////
        int carry;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The last live cycle of the champion.
        ////////////////////////////////////////////////////////////////////////
        bool alive_during_last_cycle;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The cycle to wait before executing the next instruction.
        ////////////////////////////////////////////////////////////////////////
        int cycle_to_wait;
    } champ_t;

    ////////////////////////////////////////////////////////////////////////////
    /// \typedef
    /// \brief
    /// \struct corewar_s
    ////////////////////////////////////////////////////////////////////////////
    typedef struct corewar_s {
        ////////////////////////////////////////////////////////////////////////
        /// \brief The arena of the corewar program.
        ////////////////////////////////////////////////////////////////////////
        byte_t *arena;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The array of champ.
        ////////////////////////////////////////////////////////////////////////
        champ_t **champ;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The Current cycle of the corewar program.
        ////////////////////////////////////////////////////////////////////////
        int current_cycle;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The number of cycles before the dump.
        ////////////////////////////////////////////////////////////////////////
        int dump_nbr_cycles;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The last alive champion id.
        ////////////////////////////////////////////////////////////////////////
        int last_alive;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The of live instructions.
        ////////////////////////////////////////////////////////////////////////
        int nbr_live;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The cycle to die.
        ////////////////////////////////////////////////////////////////////////
        int cycle_to_die;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The number of champions.
        ////////////////////////////////////////////////////////////////////////
        int nbr_champ;
    } corewar_t;

    ////////////////////////////////////////////////////////////////////////////
    /// \typedef
    /// \brief
    /// \struct header_s
    ////////////////////////////////////////////////////////////////////////////
    typedef struct header_s {
        ////////////////////////////////////////////////////////////////////////
        /// \brief The magic number of the program.
        ////////////////////////////////////////////////////////////////////////
        int magic;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The name of the program.
        ////////////////////////////////////////////////////////////////////////
        char prog_name[PROG_NAME_LENGTH + 1];
        ////////////////////////////////////////////////////////////////////////
        /// \brief The size of the program.
        ////////////////////////////////////////////////////////////////////////
        int prog_size;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The comment of the program.
        ////////////////////////////////////////////////////////////////////////
        char comment[COMMENT_LENGTH + 1];
    } header_t;

    ////////////////////////////////////////////////////////////////////////////
    /// \typedef
    /// \brief
    /// \struct op_s
    ////////////////////////////////////////////////////////////////////////////
    typedef struct op_s {
        ////////////////////////////////////////////////////////////////////////
        /// \brief The id of the instruction.
        ////////////////////////////////////////////////////////////////////////
        byte_t code;
        ////////////////////////////////////////////////////////////////////////
        /// \brief Tells if the instruction has a parameter byte.
        ////////////////////////////////////////////////////////////////////////
        bool has_param_byte;
        ////////////////////////////////////////////////////////////////////////
        /// \brief Tells if the instruction has an index.
        ////////////////////////////////////////////////////////////////////////
        bool is_index;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The number of parameters of the instruction.
        ////////////////////////////////////////////////////////////////////////
        int nbr_params;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The duration of the instruction.
        ////////////////////////////////////////////////////////////////////////
        int op_duration;
        ////////////////////////////////////////////////////////////////////////
        /// \brief The associated function to the instruction.
        /// \param global The global structure of the corewar program.
        /// \param champion The champion that executes the instruction.
        /// \note This function is called by the execute_instruction function.
        /// \note An instruction is executed when the cycle_before_instruction
        /// is equal to 0.
        ////////////////////////////////////////////////////////////////////////
        void (*exec)(corewar_t *global, champ_t *champion);
        ////////////////////////////////////////////////////////////////////////
        /// \brief The function that checks if the instruction is valid.
        /// \param op_code The op_code of the instruction.
        /// \param pars_byte The parameter byte of the instruction.
        /// \param params The parameters of the instruction.
        /// \return true if the instruction is valid, false otherwise.
        /// \note This function is called by the execute_instruction function.
        ////////////////////////////////////////////////////////////////////////
        bool (*check)(byte_t op_code, byte_t pars_byte, byte_t *params);
    } op_t;

    ////////////////////////////////////////////////////////////////////////////
    /// \typedef
    /// \brief
    /// \enum op_code_e
    ////////////////////////////////////////////////////////////////////////////
    typedef enum op_code_e {
        LIVE_ = 0x01,
        LD___ = 0x02,
        ST___ = 0x03,
        ADD__ = 0x04,
        SUB__ = 0x05,
        AND__ = 0x06,
        OR___ = 0x07,
        XOR__ = 0x08,
        ZJMP_ = 0x09,
        LDI__ = 0x0a,
        STI__ = 0x0b,
        FORK_ = 0x0c,
        LLD__ = 0x0d,
        LLDI_ = 0x0e,
        LFORK = 0x0f,
        AFF__ = 0x10,
    } op_code_t;

    ////////////////////////////////////////////////////////////////////////////
    /// @}
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_FUNCTIONS
    /// \brief All the FUNCTIONS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_LOOP_FUNCTIONS
    /// \brief All the LOOP_FUNCTIONS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    bool different_champ_alive(corewar_t *global);
    bool corewar_loop_condition(corewar_t *global);
    void dump_memory(byte_t *arena);
    void display_winner(corewar_t *global);
    int corewar_loop(corewar_t *global);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_LOOP_FUNCTIONS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_INIT_FUNCTIONS
    /// \brief All the INIT from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_VALIDITY_CHECKERS
    /// \brief All the VALIDITY_CHECKERS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    bool check_header_magic_number_prog_size(header_t header, int size);
    bool check_header_prog_name(header_t header);
    bool check_header_comment(header_t header);
    bool champions_validity_checkers(params_progs_t *prog);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_VALIDITY_CHECKERS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_INIT_EXITS_FUNCTIONS
    /// \brief All the INIT_EXITS_FUNCTIONS from the COREWAR part of the project
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_EXIT_INIT_CHAMPIONS
    /// \brief All the EXIT_INIT_CHAMPIONS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    void *e_init_comment(champ_t *champ);
    void *e_init_name(champ_t *champ);
    void *e_init_regs(champ_t *champ);
    void *e_init_params_bytes(champ_t *champ);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_EXIT_INIT_CHAMPIONS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_EXIT_INIT_COREWAR
    /// \brief All the EXIT_INIT_COREWAR from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    int e_init_struct(params_t *params);
    int e_init_champs(corewar_t *glob, params_t *params);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_EXIT_INIT_COREWAR
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_INIT_EXITS_FUNCTIONS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_INIT_CHAMPIONS
    /// \brief All the INIT_CHAMPIONS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    void init_default_values(params_progs_t *prog, champ_t *champ);
    champ_t *init_champion(params_progs_t *prog, int *mall_vs);
    bool load_champ(params_progs_t *prog, byte_t *arena);
    bool init_champs(corewar_t *glob, params_t *params);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_INIT_CHAMPIONS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_INIT_COREWAR
    /// \brief All the INIT_COREWAR from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    int init_corewar_programm(params_t *params);

    corewar_t *init_corewar(params_t *param, int mall_v1, int mv2, int mv3);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_INIT_COREWAR
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_INIT_FUNCTIONS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_PARAMS_TREATMENT
    /// \brief All the PARAMS_TREATMENT from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_PARAMS_GETTERS
    /// \brief All the PARAMS_GETTERS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    bool add_progname(char **argv, params_t *params, int prog, int mv1);
    bool add_pnbr_name(char **argv, params_t *params, int prog, int mv1);
    bool add_adress_name(char **argv, params_t *params, int prog, int mv1);
    bool add_pnbr_adress_name(char **argv, params_t *params, int prog, int mv1);
    bool add_adress_pnbr_name(char **argv, params_t *params, int prog, int mv1);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_PARAMS_GETTERS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_INIT_PARAMS
    /// \brief All the INIT_PARAMS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    void *e_init_params(params_t *params);

    success_t get_dump_nbr_cycle(char **argv, params_t *params);
    bool get_params_prog_nbr(char **argv, params_t *params);
    bool init_params_progs(params_t *params, int mall_v1);
    bool get_params_progs(char **argv, params_t *params, int mall_v1);
    params_t *init_params(char **argv, int mall_v1, int mall_v2);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_INIT_PARAMS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_PROGS_PARAMS_TREATMENT
    /// \brief All the PROGS_PARAMS_TREATMENT from the COREWAR part of the
    /// project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    bool one_adress_is_set(params_progs_t **progs);
    bool all_adresses_are_set(params_progs_t **progs);

    bool params_check_update(params_t *params);

    int get_next_valid_prog_nbr(params_progs_t **progs);
    void set_prog_numbers(params_progs_t **progs);
    bool mulitple_prog_nbr_checker(params_progs_t **progs, int i, int prog_nbr);
    bool mulitple_prog_nbr(params_progs_t **progs);

    void swapprogs(params_progs_t **progs, int i, int j);
    void sort_progs(params_progs_t **progs);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_PROGS_PARAMS_TREATMENT
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_PARAMS_TREATMENT
    ////////////////////////////////////////////////////////////////////////////

    int display_corewar_help(char **corewar_help_array);
    bool check_corewar_args(int argc, char **argv);
    int corewar_programm_main(int argc, char **argv);

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_UTILS
    /// \brief All the UTILS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_ARENA_UTILS
    /// \brief All the ARENA_UTILS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    short get_2b_mem(corewar_t *corewar, int pos_mem);
    int get_4b_mem(corewar_t *corewar, int pos_mem);
    int get_arena_adress(int adress);
    void write_4b_mem(corewar_t *global, int val, int pos_mem);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_ARENA_UTILS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_CONVERTERS_UTILS
    /// \brief All the CONVERTERS_UTILS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    int get_len(int arg_type);
    int get_len_mod(int arg_type);
    short get_short(byte_t *params, int adress);
    int get_type_p1(byte_t params);
    int get_type_p2(byte_t params);
    int get_type_p3(byte_t params);
    int get_value(int arg_type, int pos, champ_t *champion, corewar_t *glo);
    int get_value_mod(int arg_type, int pos, champ_t *champion, corewar_t *glo);
    int reverse_int(int nb);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_CONVERTERS_UTILS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_FILE_PARSING_UTILS
    /// \brief All the FILE_PARSING_UTILS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    bool get_header(header_t *header, char const *filepath);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_FILE_PARSING_UTILS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_FREE_UTILS
    /// \brief All the FREE_UTILS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    void free_champs(champ_t **champ);
    void free_corewar(corewar_t *glob);
    void free_params_progs(params_progs_t **params_progs);
    void free_params(params_t *params);
    void freen_champs(champ_t **champ, int i);
    void freen_params_progs(params_progs_t **params_progs, int n);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_FREE_UTILS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_LOOP_UTILS
    /// \brief All the LOOP_UTILS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    bool different_champ_alive(corewar_t *global);
    void display_dump(byte_t *arena);
    void display_winner(corewar_t *global);
    void dump_memory(byte_t *arena);
    void reset_champ_params(champ_t *champ);
    void update_champ_params(byte_t *arena, champ_t *champ);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_LOOP_UTILS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_CHAMPDUP_UTILS
    /// \brief All the CHAMPDUP_UTILS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    void *e_champdup_comment(champ_t *champ);
    void *e_champdup_name(champ_t *champ);
    void *e_champdup_params(champ_t *champ);
    void *e_champdup_regs(champ_t *champ);

    champ_t *champdup(champ_t *champ, int new_champ_pc, int *mall_vs);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_CHAMPDUP_UTILS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_UTILS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_EXECUTORS_CHECKERS
    /// \brief All the EXECUTORS_CHECKERS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    bool check_01_live(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_02_ld(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_03_st(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_04_add(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_05_sub(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_06_and(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_07_or(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_08_xor(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_09_zjmp(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_10_ldi(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_11_sti(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_12_fork(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_13_lld(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_14_lldi(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_15_lfork(byte_t op_code, byte_t pars_byte, byte_t *params);
    bool check_16_aff(byte_t op_code, byte_t pars_byte, byte_t *params);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_EXECUTORS_CHECKERS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_EXECUTORS
    /// \brief All the EXECUTORS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    void exec_01_live(corewar_t *global, champ_t *champion);
    void exec_02_ld(corewar_t *global, champ_t *champion);
    void exec_03_st(corewar_t *global, champ_t *champion);
    void exec_04_add(corewar_t *global, champ_t *champion);
    void exec_05_sub(corewar_t *global, champ_t *champion);
    void exec_06_and(corewar_t *global, champ_t *champion);
    void exec_07_or(corewar_t *global, champ_t *champion);
    void exec_08_xor(corewar_t *global, champ_t *champion);
    void exec_09_zjmp(corewar_t *global, champ_t *champion);
    void exec_10_ldi(corewar_t *global, champ_t *champion);
    void exec_11_sti(corewar_t *global, champ_t *champion);
    void exec_12_fork(corewar_t *global, champ_t *champion);
    void exec_13_lld(corewar_t *global, champ_t *champion);
    void exec_14_lldi(corewar_t *global, champ_t *champion);
    void exec_15_lfork(corewar_t *global, champ_t *champion);
    void exec_16_aff(corewar_t *global, champ_t *champion);

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_EXECUTORS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_FUNCTIONS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \addtogroup COREWAR_GLOBALS_ARRAYS
    /// \brief All the GLOBALS ARRAYS from the COREWAR part of the project.
    /// @{
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The help message of the corewar program.
    /// \def corewar_help
    /// \note The message is displayed when the program is called with the -h
    /// flag.
    ////////////////////////////////////////////////////////////////////////////
    static char const * const corewar_help[] = {
        "USAGE\n",
        "./corewar [-dump nbr_cycle] [[-n prog_number] [-a load_address] ",
        "prog_name] ...\n",
        "DESCRIPTION\n",
        "-dump nbr_cycle dumps the memory after the nbr_cycle execution ",
        "(if the round isn’t already over) with the following format: 32 ",
        "bytes/line in hexadecimal (A0BCDEFE1DD3...)\n",
        "-n prog_number sets the next program’s number. By default, the first ",
        "free number in the parameter order\n",
        "-a load_address sets the next program’s loading address. When no ",
        "address is specified, optimize the addresses so that the processes ",
        "are as far away from each other as possible. The addresses are ",
        "MEM_SIZE modulo.\n",
        NULL,
    };

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The op_tab of the corewar program.
    /// \def op_tab
    /// \note The op_tab is used to get the informations about the opcodes.
    ////////////////////////////////////////////////////////////////////////////
    static op_t const op_tab[] = {
        {0,     0, 0, 0, 0, NULL, NULL},
        {LIVE_, 0, 0, 1, 10, exec_01_live, check_01_live},
        {LD___, 1, 1, 2, 5, exec_02_ld, check_02_ld},
        {ST___, 0, 1, 2, 5, exec_03_st, check_03_st},
        {ADD__, 1, 1, 3, 10, exec_04_add, check_04_add},
        {SUB__, 1, 1, 3, 10, exec_05_sub, check_05_sub},
        {AND__, 1, 1, 3, 6, exec_06_and, check_06_and},
        {OR___, 1, 1, 3, 6, exec_07_or, check_07_or},
        {XOR__, 1, 1, 3, 6, exec_08_xor, check_08_xor},
        {ZJMP_, 0, 1, 1, 20, exec_09_zjmp, check_09_zjmp},
        {LDI__, 1, 0, 3, 25, exec_10_ldi, check_10_ldi},
        {STI__, 1, 0, 3, 25, exec_11_sti, check_11_sti},
        {FORK_, 1, 1, 1, 800, exec_12_fork, check_12_fork},
        {LLD__, 0, 1, 2, 10, exec_13_lld, check_13_lld},
        {LLDI_, 1, 1, 3, 50, exec_14_lldi, check_14_lldi},
        {LFORK, 0, 1, 1, 1000, exec_15_lfork, check_15_lfork},
        {AFF__, 1, 0, 1, 2, exec_16_aff, check_16_aff},
        {0,     0, 0, 0, 0, NULL, NULL},
    };

    #define DIR_IDX 5
    #define IS_IDX(x) (x == DIR) ? DIR_IDX : REG
    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR_GLOBALS_ARRAYS
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// @} END COREWAR
    ////////////////////////////////////////////////////////////////////////////

#endif /* !COREWAR_PROGRAMM_HEADER_H_ */
